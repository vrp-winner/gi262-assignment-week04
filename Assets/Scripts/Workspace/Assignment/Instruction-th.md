# Assignment 04: ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ Data Structures ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Game Development

## üéØ ‡∏à‡∏∏‡∏î‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ

- ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô LinkedList ‡πÉ‡∏ô C#
- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Hashtable ‡πÅ‡∏•‡∏∞ Dictionary
- ‡∏ô‡∏≥ Data Structures ‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡πÄ‡∏Å‡∏°
- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡πÑ‡∏î‡∏ô‡∏≤‡∏°‡∏¥‡∏Å‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô code ‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

## üìö ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Assignment

- **Lecture Methods (3 methods)** - ‡∏Å‡∏≤‡∏£ implement ‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏î‡πâ‡∏ß‡∏¢ Data Structures ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô
- **Assignment Methods (11 methods)** - ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ Data Structures ‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÄ‡∏Å‡∏°

---

## Lecture Methods

Methods ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î Data Structures ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô Implement ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡πÅ‡∏ï‡πà‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô

### 1. LCT01_SyntaxLinkedList

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô LinkedList ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ‡∏•‡∏ö ‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

**Method Signature:**
```csharp
void LCT01_SyntaxLinkedList()
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏™‡∏£‡πâ‡∏≤‡∏á LinkedList ‡∏Ç‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó string
- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ó‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á LinkedList ‡∏î‡πâ‡∏ß‡∏¢ `AddLast("Node 1")` ‡πÅ‡∏•‡∏∞ `AddLast("Node 2")`
- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á LinkedList ‡∏î‡πâ‡∏ß‡∏¢ `AddFirst("Node 0")`
- ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÉ‡∏ô LinkedList ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ foreach loop
- ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô LinkedList ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ First, Last, ‡πÅ‡∏•‡∏∞ Find
- ‡πÄ‡∏û‡∏¥‡πà‡∏° node ‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏±‡∏á node ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏î‡πâ‡∏ß‡∏¢ `AddBefore` ‡πÅ‡∏•‡∏∞ `AddAfter`
- ‡∏•‡∏ö Node ‡πÅ‡∏£‡∏Å‡∏î‡πâ‡∏ß‡∏¢ `RemoveFirst()` ‡πÅ‡∏•‡∏∞‡∏•‡∏ö Node ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏î‡πâ‡∏ß‡∏¢ `Remove()`
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î

**Test Case:**
- **Input:** ‡πÑ‡∏°‡πà‡∏°‡∏µ parameters
- **Expected Output:** ‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "LinkedList ...", ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ nodes, "first", "last", "firstNode.Previous is null", "lastNode.Next is null", ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡∏∞‡∏•‡∏ö

### 2. LCT02_SyntaxHashTable

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Hashtable ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á ‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

**Method Signature:**
```csharp
void LCT02_SyntaxHashTable()
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏™‡∏£‡πâ‡∏≤‡∏á Hashtable
- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô Hashtable ‡∏î‡πâ‡∏ß‡∏¢ keys ‡∏ï‡πà‡∏≤‡∏á‡∏ä‡∏ô‡∏¥‡∏î (int ‡πÅ‡∏•‡∏∞ string)
- ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Hashtable ‡∏î‡πâ‡∏ß‡∏¢ Key ‡πÅ‡∏•‡∏∞ cast ‡πÄ‡∏õ‡πá‡∏ô string
- ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Hashtable ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ foreach DictionaryEntry
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á Key ‡∏î‡πâ‡∏ß‡∏¢ `ContainsKey()`
- ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Hashtable ‡∏î‡πâ‡∏ß‡∏¢ `Remove()`
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î

**Test Case:**
- **Input:** ‡πÑ‡∏°‡πà‡∏°‡∏µ parameters
- **Expected Output:** ‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "fruit1: Apple", "fruit2: Banana", "badFruit: Rotten Tomato", "found 2", "table ..."

### 3. LCT03_SyntaxDictionary

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Dictionary ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á ‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

**Method Signature:**
```csharp
void LCT03_SyntaxDictionary()
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏™‡∏£‡πâ‡∏≤‡∏á Dictionary ‡πÇ‡∏î‡∏¢‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á Key ‡πÄ‡∏õ‡πá‡∏ô int ‡πÅ‡∏•‡∏∞ Value ‡πÄ‡∏õ‡πá‡∏ô string
- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô Dictionary ‡∏î‡πâ‡∏ß‡∏¢ `Add()` ‡πÅ‡∏•‡∏∞ indexer
- ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Dictionary ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ foreach KeyValuePair
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏µ‡∏¢‡πå‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢ `ContainsKey()`
- ‡∏î‡∏∂‡∏á key ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏î‡πâ‡∏ß‡∏¢ `Keys` property
- ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Dictionary ‡∏î‡πâ‡∏ß‡∏¢ `Remove()`
- Clear ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Dictionary ‡∏î‡πâ‡∏ß‡∏¢ `Clear()`
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î

**Test Case:**
- **Input:** ‡πÑ‡∏°‡πà‡∏°‡∏µ parameters
- **Expected Output:** ‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "Dictionary has 3 keys", "has key 1 : True", "value of key 1 : Apple", "All keys in dictionary:", "Dictionary has 2 keys"

---

## Assignment Methods

Methods ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ Data Structures ‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÄ‡∏Å‡∏° ‡πÅ‡∏•‡∏∞‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô

### AS01_CountWords

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥‡πÉ‡∏ô array ‡∏Ç‡∏≠‡∏á strings ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Dictionary

**Method Signature:**
```csharp
void AS01_CountWords(string[] words)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡πÉ‡∏ä‡πâ Dictionary<string, int> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≥
- ‡∏ô‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≥‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ for loop ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô array
- ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏≥‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ count ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡πÉ‡∏´‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÇ‡∏î‡∏¢‡πÅ‡∏õ‡∏•‡∏á Keys ‡πÅ‡∏•‡∏∞ Values ‡πÄ‡∏õ‡πá‡∏ô array ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ for loop
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö "word: '{word}' count: {count}"

**Test Cases:**
1. **Input:** `["apple", "banana", "apple", "cherry", "banana", "apple"]`
   **Expected Output:**
   ```
   word: 'apple' count: 3
   word: 'banana' count: 2
   word: 'cherry' count: 1
   ```

2. **Input:** `["hello", "world", "hello"]`
   **Expected Output:**
   ```
   word: 'hello' count: 2
   word: 'world' count: 1
   ```

3. **Input:** `["test"]`
   **Expected Output:**
   ```
   word: 'test' count: 1
   ```

### AS02_CountNumber

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÉ‡∏ô array ‡∏Ç‡∏≠‡∏á integers ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Dictionary

**Method Signature:**
```csharp
void AS02_CountNumber(int[] numbers)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡πÉ‡∏ä‡πâ Dictionary<int, int> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
- ‡∏ô‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ for loop ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô array
- ‡∏ñ‡πâ‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ count ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÉ‡∏´‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÇ‡∏î‡∏¢‡πÅ‡∏õ‡∏•‡∏á Keys ‡πÅ‡∏•‡∏∞ Values ‡πÄ‡∏õ‡πá‡∏ô array ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ for loop
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö "number: {number} count: {count}"

**Test Cases:**
1. **Input:** `[1, 2, 3, 2, 1, 3, 1]`
   **Expected Output:**
   ```
   number: 1 count: 3
   number: 2 count: 2
   number: 3 count: 2
   ```

2. **Input:** `[5, 5, 5]`
   **Expected Output:**
   ```
   number: 5 count: 3
   ```

3. **Input:** `[0, -1, 2, 0, -1]`
   **Expected Output:**
   ```
   number: 0 count: 2
   number: -1 count: 2
   number: 2 count: 1
   ```

### AS03_CheckValidBrackets

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡πÉ‡∏ô string ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Dictionary ‡πÅ‡∏•‡∏∞ LinkedList

**Method Signature:**
```csharp
void AS03_CheckValidBrackets(string input)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡πÉ‡∏ä‡πâ Dictionary<char, char> ‡πÄ‡∏û‡∏∑‡πà‡∏≠ map ‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡∏õ‡∏¥‡∏î `{('(', ')'), ('[', ']'), ('{', '}')}`
- ‡πÉ‡∏ä‡πâ LinkedList<char> ‡πÄ‡∏õ‡πá‡∏ô stack ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡πÄ‡∏õ‡∏¥‡∏î
- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô string ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£
- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ stack (AddLast)
- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡∏õ‡∏¥‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ stack ‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• "Valid" ‡∏´‡∏£‡∏∑‡∏≠ "Invalid"

**Test Cases:**
1. **Input:** `"()"`
   **Expected Output:** `Valid`

2. **Input:** `"([{}])"`
   **Expected Output:** `Valid`

3. **Input:** `"(]"`
   **Expected Output:** `Invalid`

4. **Input:** `"abc(def)ghi"`
   **Expected Output:** `Valid`

5. **Input:** `""`
   **Expected Output:** `Valid`

### AS04_PrintReverseLinkedList

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏û‡∏¥‡∏°‡∏û‡πå LinkedList ‡πÉ‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç list ‡πÄ‡∏î‡∏¥‡∏°

**Method Signature:**
```csharp
void AS04_PrintReverseLinkedList(LinkedList<int> list)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ list ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô 0 elements
- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Last node ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ while loop ‡∏ß‡∏ô‡πÑ‡∏õ Previous
- ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ node ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á node ‡πÅ‡∏£‡∏Å

**Test Cases:**
1. **Input:** LinkedList with [1, 2, 3, 4, 5]
   **Expected Output:**
   ```
   5
   4
   3
   2
   1
   ```

2. **Input:** LinkedList with [42]
   **Expected Output:** `42`

3. **Input:** Empty LinkedList
   **Expected Output:** `List is empty`

### AS05_FindMiddleElement

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏´‡∏≤ element ‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á LinkedList ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ two-pointer technique

**Method Signature:**
```csharp
void AS05_FindMiddleElement(LinkedList<string> list)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ list ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô 0 elements
- ‡πÉ‡∏ä‡πâ slow ‡πÅ‡∏•‡∏∞ fast pointers ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å First node
- ‡πÉ‡∏ô while loop: slow ‡πÄ‡∏î‡∏¥‡∏ô 1 ‡∏Å‡πâ‡∏≤‡∏ß, fast ‡πÄ‡∏î‡∏¥‡∏ô 2 ‡∏Å‡πâ‡∏≤‡∏ß
- ‡πÄ‡∏°‡∏∑‡πà‡∏≠ fast ‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î slow ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà middle
- ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á middle element

**Test Cases:**
1. **Input:** `["A", "B", "C"]`
   **Expected Output:** `B`

2. **Input:** `["A", "B", "C", "D"]`
   **Expected Output:** `C`

3. **Input:** `["A"]`
   **Expected Output:** `A`

4. **Input:** Empty LinkedList
   **Expected Output:** `List is empty`

### AS06_MergeDictionaries

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏£‡∏ß‡∏°‡∏™‡∏≠‡∏á Dictionary ‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á keys ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô

**Method Signature:**
```csharp
void AS06_MergeDictionaries(Dictionary<string, int> dict1, Dictionary<string, int> dict2)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏™‡∏£‡πâ‡∏≤‡∏á Dictionary ‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å dict1
- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô dict2 ‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ merged dictionary
- ‡∏ñ‡πâ‡∏≤ key ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡∏ö‡∏ß‡∏Å‡∏Ñ‡πà‡∏≤ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° key ‡πÉ‡∏´‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• merged dictionary ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö "key: {key}, value: {value}"

**Test Cases:**
1. **Input:** dict1 = {"apple":3, "banana":2}, dict2 = {"apple":1, "cherry":4}
   **Expected Output:** ‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "key: apple, value: 4", "key: banana, value: 2", "key: cherry, value: 4"

2. **Input:** dict1 = {"a":1, "b":2}, dict2 = {"c":3, "d":4}
   **Expected Output:** ‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "key: a, value: 1", "key: b, value: 2", "key: c, value: 3", "key: d, value: 4"

### AS07_RemoveDuplicatesFromLinkedList

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏•‡∏ö duplicates ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å LinkedList ‡πÇ‡∏î‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å

**Method Signature:**
```csharp
void AS07_RemoveDuplicatesFromLinkedList(LinkedList<int> list)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ list ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô <= 1 elements
- ‡πÉ‡∏ä‡πâ Dictionary<int, bool> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô‡πÅ‡∏•‡πâ‡∏ß
- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô list ‡πÅ‡∏•‡∏∞‡∏•‡∏ö node ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• list ‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö duplicates

**Test Cases:**
1. **Input:** [1, 2, 2, 3, 3, 3, 4]
   **Expected Output:**
   ```
   1
   2
   3
   4
   ```

2. **Input:** [5, 5, 5, 5]
   **Expected Output:** `5`

3. **Input:** [1, 2, 3, 4]
   **Expected Output:**
   ```
   1
   2
   3
   4
   ```

### AS08_TopFrequentNumber

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏´‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡∏ö‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô array

**Method Signature:**
```csharp
void AS08_TopFrequentNumber(int[] numbers)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ array ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠ empty
- ‡πÉ‡∏ä‡πâ Dictionary ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
- ‡∏´‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö "{number} count: {count}"

**Test Cases:**
1. **Input:** `[1, 2, 3, 2, 2, 1]`
   **Expected Output:** `2 count: 3`

2. **Input:** `[5, 5, 5, 5]`
   **Expected Output:** `5 count: 4`

3. **Input:** `[1, 2, 3, 4]`
   **Expected Output:** `1 count: 1`

4. **Input:** `[]`
   **Expected Output:** `Input array is empty`

### AS09_PlayerInventory

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï inventory ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÇ‡∏î‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°

**Method Signature:**
```csharp
void AS09_PlayerInventory(Dictionary<string, int> inventory, string itemName, int quantity)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ inventory ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‡∏ñ‡πâ‡∏≤ itemName ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡πÉ‡∏´‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• inventory ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï

**Test Cases:**
1. **Input:** inventory = `{"sword":1, "potion":5}`, itemName = `"shield"`, quantity = `2`
   **Expected Output:** ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ `sword: 1`, `potion: 5`, `shield: 2`

2. **Input:** inventory = `{"sword":1, "potion":5}`, itemName = `"potion"`, quantity = `3`
   **Expected Output:** ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ `sword: 1`, `potion: 8`

3. **Input:** inventory = null
   **Expected Output:** `Inventory is null`

### EX01_GameEventQueue

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• event ‡πÉ‡∏ô queue ‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°

**Method Signature:**
```csharp
void EX01_GameEventQueue(LinkedList<GameEvent> eventQueue)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö queue ‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠ null
- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏∏‡∏Å event ‡πÉ‡∏ô queue ‡πÇ‡∏î‡∏¢‡∏î‡∏∂‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ï‡πâ‡∏ô (RemoveFirst)
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• "Processing event: {event.Name}"
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• "Remaining events in queue: {count}"
- ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó event ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°

**Test Case:**
- **Input:** Queue with events `"enemy":"Goblin appeared"`, `"powerup":"Health boost found"`, `"level":"Reached level 2"`
- **Expected Output:**
```
Processing event: Goblin appeared
Remaining events in queue: 2
Enemy event processed - Goblin appeared
Processing event: Health boost found
Remaining events in queue: 1
Power-up event processed - Health boost found
Processing event: Reached level 2
Remaining events in queue: 0
Level event processed - Reached level 2
```

### EX02_PlayerStatsTracker

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

**Method Signature:**
```csharp
void EX02_PlayerStatsTracker(Dictionary<string, int> playerStats, string statName, int value)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö playerStats ‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‡∏ñ‡πâ‡∏≤ statName ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° stat ‡πÉ‡∏´‡∏°‡πà
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• "Updated {statName}: {newValue}"
- ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï

**Test Cases:**
1. **Input:** playerStats = `{"kills":10, "deaths":2}`, statName = `"assists"`, value = `5`
   **Expected Output:** ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ Updated assists: 5, "Current player statistics:", "kills: 10", "deaths: 2", "assists: 5"
   ```
    Updated assists: 5
    Current player statistics:
    kills: 10
    deaths: 2
    assists: 5
   ```

2. **Input:** playerStats = `{"kills":10, "deaths":2}`, statName = `"kills"`, value = `3`
   **Expected Output:** ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ "Updated kills: 13", "Current player statistics:", "kills: 13", "deaths: 2"
    ```
    Updated kills: 13
    Current player statistics:
    kills: 13
    deaths: 2
    ```
